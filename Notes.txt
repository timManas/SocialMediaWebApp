Flow is 

Incoming: app.js
Outoung: app.js -> router.js
                        -> Goes to userController -> register() -> displays home-guest.ejs
                        -> Register: userController.js -> registers() -> users.js -> register() -> Adds onto MongoDB

1. How to launch/start the app ?
- From the root folder of this project
- Type in "node app"  or "node app.js"

2. How to set up Automatic App Update
    - Install nodemon "npm install nodemon"
    - Go to package.json
    - Add "watch": "nodemon app"
    - Run npm run watch

3. You will need to create a route
- Essentially, everytie you get a app.get() or app.post() you will be using a router to tell whhere to go
- Better for organization

4. "require(router.js)" has two functionalities 
i - Executes file inside its 
ii - Retunrs all the objects,variables, functions..etc  INSIDE that file which we can now use in the invoking class (ex. App.js)


6. Purpose of the Model
- Where business logic resides
- Ex. Password must be unique


5. Purpose of the Controller
- Accept input (network request) and convert requests into commands to be used by the Model 
- Depending on request, controller will call upon the appopriate Model / business logic

6. Connection to Database is done on db.js

7. Once we connect to the database THEN and ONLY THEN do we start listening for requests

8. We create db.js file and export the contents so we dont have to constantly "require" and create multiple instances
of the db 

9. Hence to get stuff from the db, you can just "require(db.js)" and you now have access to db capabilities for CRUD

10. Use dotenv (npm install dotenv) to encapsulate your db password

11. How to acces Env variables
- download dotenv
- create .env file
- create variable name  "CONNECTIONSTRING=XXX...."
- access it using process.env.CONNECTIONSTRING 


12. Remmeber its the Model and not the controller handling the business Logic
    - Hence we have created the "User.js" model


13. What is a Promise in JS ? 
- An object that represents the eventual completion of an asynchronous operation
- Has either Resolve or Reject


14. Promise vs Traditional Callback approach ?
Promises
- Allows us to chain asynchronous events for promises
- Much cleaner code

Callback 
- Code inside of code (Nested code)

15. The arrow funciton => Does NOT modify the "this" keyword


16. You can use "Await" keyboard to ensure that asychrnous functions are executed orderly
17. Await requires a "async" function to be run

18. Hash a password before storing into Database. Not the samething as Encrypting. One way conversation
- Useb bcryptJS to hash your password before storing

19. Once a user has logged on, the server has no memory of the user has already logged on
- Hence the server needs to "trust" the client once it has logged in
- We can use two solutions: Sessions or Tokens

20. Sessions uses cookies. They are unique for each browser(Chrome vs Firefox) which successfully logged in
- Session  info should be stored in MongoDB instead of the memory

21. We use flash to store any errors to the user if they logged incorrectly

22. You want validation on both side
- Server side for security
- Browser side for UX

23. Gravatar for setting up user Avatar

24. We only want logged in accounts to create post

25. We create the header.ejs file so that the Header is consistent,
We dont have to change the avatar everytime we create a page


26. You can use <% %> to do dynamic stuff using JS

27.
<% 'Scriptlet' tag, for control-flow, no output
<%_ ‘Whitespace Slurping’ Scriptlet tag, strips all whitespace before it
<%= Outputs the value into the template (HTML escaped)
<%- Outputs the unescaped value into the template
<%# Comment tag, no execution, no output
<%% Outputs a literal '<%'
%> Plain ending tag
-%> Trim-mode ('newline slurp') tag, trims following newline
_%> ‘Whitespace Slurping’ ending tag, removes all whitespace after it


18. Theres two different types of /create-post
- One for GET and another for post
- Two are unique and independent from each other

29. insertOne is a asynchonous Operation. We have no idea how long it will take to store in DB
- We have two solutions, use then().catch() syntax or async keyword

30. 