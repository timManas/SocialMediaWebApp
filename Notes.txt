Flow is 

Incoming: app.js
Outoung: app.js -> router.js
                        -> Goes to userController -> register() -> displays home-guest.ejs
                        -> Register: userController.js -> registers() -> users.js -> register() -> Adds onto MongoDB

1. How to launch/start the app ?
- From the root folder of this project
- Type in "node app"  or "node app.js"

2. How to set up Automatic App Update
    - Install nodemon "npm install nodemon"
    - Go to package.json
    - Add "watch": "nodemon app"
    - Run npm run watch

3. You will need to create a route
- Essentially, everytie you get a app.get() or app.post() you will be using a router to tell whhere to go
- Better for organization

4. "require(router.js)" has two functionalities 
i - Executes file inside its 
ii - Retunrs all the objects,variables, functions..etc  INSIDE that file which we can now use in the invoking class (ex. App.js)


6. Purpose of the Model
- Where business logic resides
- Ex. Password must be unique


5. Purpose of the Controller
- Accept input (network request) and convert requests into commands to be used by the Model 
- Depending on request, controller will call upon the appopriate Model / business logic

6. Connection to Database is done on db.js

7. Once we connect to the database THEN and ONLY THEN do we start listening for requests

8. We create db.js file and export the contents so we dont have to constantly "require" and create multiple instances
of the db 

9. Hence to get stuff from the db, you can just "require(db.js)" and you now have access to db capabilities for CRUD

10. Use dotenv (npm install dotenv) to encapsulate your db password

11. How to acces Env variables
- download dotenv
- create .env file
- create variable name  "CONNECTIONSTRING=XXX...."
- access it using process.env.CONNECTIONSTRING 


12. Remmeber its the Model and not the controller handling the business Logic
    - Hence we have created the "User.js" model


13. What is a Promise in JS ? 
- An object that represents the eventual completion of an asynchronous operation
- Has either Resolve or Reject


14. Promise vs Traditional Callback approach ?
Promises
- Allows us to chain asynchronous events for promises
- Much cleaner code

Callback 
- Code inside of code (Nested code)

15. The arrow funciton => Does NOT modify the "this" keyword


16. You can use "Await" keyboard to ensure that asychrnous functions are executed orderly
17. Await requires a "async" function to be run

18. Hash a password before storing into Database. Not the samething as Encrypting. One way conversation
- Useb bcryptJS to hash your password before storing

19. Once a user has logged on, the server has no memory of the user has already logged on
- Hence the server needs to "trust" the client once it has logged in
- We can use two solutions: Sessions or Tokens

20. Sessions uses cookies. They are unique for each browser(Chrome vs Firefox) which successfully logged in
- Session  info should be stored in MongoDB instead of the memory